{
  "created_at": "2026-02-18T07:53:43.349514Z",
  "epic": {
    "data": {
      "branch_name": "fn-6-fix-losetup-pre-flight-detection-and",
      "completion_review_status": "ship",
      "completion_reviewed_at": "2026-02-17T20:52:08.970765Z",
      "created_at": "2026-02-17T19:21:55.156603Z",
      "default_impl": null,
      "default_review": null,
      "default_sync": null,
      "depends_on_epics": [],
      "id": "fn-6-fix-losetup-pre-flight-detection-and",
      "next_task": 1,
      "plan_review_status": "ship",
      "plan_reviewed_at": "2026-02-17T19:48:21.064272Z",
      "spec_path": ".flow/specs/fn-6-fix-losetup-pre-flight-detection-and.md",
      "status": "open",
      "title": "Fix losetup pre-flight detection and EFI boot label in ISO builder",
      "updated_at": "2026-02-18T07:52:26.751645Z"
    },
    "spec": "# Fix losetup pre-flight detection and EFI boot label in ISO builder\n\n## Overview\n\nThe ISO builder's losetup pre-flight check (PR #4, commit `2788642`) is too weak. It runs `losetup --find` (query-only: prints next available `/dev/loopN`) but mkefiboot internally runs `losetup --find --show <file>` (actual attachment). These test fundamentally different capabilities \u2014 the query can succeed in environments where attachment fails (loop device nodes exist but are non-functional).\n\nAdditionally, when `--skip-mkefiboot` activates and `-V \"SurfaceLinux-43\"` changes the ISO volume label, the efiboot.img's internal grub.cfg still references the original Fedora label. On UEFI USB boot, GRUB searches for a volume with the old label, fails to find it, and boot breaks. The current README incorrectly claims this path is safe.\n\n**Post-fn-6.1 discovery**: The `_verify_no_duplicate_inst_ks()` function hard-fails looking for `isolinux.cfg`/`syslinux.cfg`, which Fedora 43 does not ship (BIOS boot uses GRUB2 since Fedora 37). Additionally, when `--skip-mkefiboot` is active, the efiboot.img's internal grub.cfg lacks `inst.ks=` injection and has stale `hd:LABEL=` references.\n\n## Scope\n\n**Phase 1 (fn-6.1 \u2014 done):**\n- Strengthen losetup pre-flight to test actual loop device attachment\n- Defense-in-depth retry on mkefiboot failure\n- Add `mtools` to Containerfile\n- `patch_efiboot_label` for volume label fixup in efiboot.img\n- Duplicate `inst.ks` detection framework\n\n**Phase 2 (fn-6.2 \u2014 new):**\n- Fix BIOS config verification to use GRUB2 paths (`boot/grub2/grub.cfg`) instead of isolinux/syslinux\n- Add ISO-level `EFI/BOOT/grub.cfg` verification (optical disc UEFI boot path)\n- Restructure verification timing: ISO-level configs pre-patch, efiboot.img post-patch\n- Expand efiboot.img patching to inject `inst.ks=` and replace `hd:LABEL=` references\n- Rename `patch_efiboot_label` \u2192 `patch_efiboot` to reflect expanded scope\n\n## Quick commands\n\n```bash\n# Build ISO in container\nsudo podman build -t surface-iso-builder -f iso/Containerfile iso/\nsudo podman run --rm -v \"$PWD:/build:Z\" surface-iso-builder /build/iso/build-iso.sh --validate-only\n\n# ShellCheck\nshellcheck iso/build-iso.sh\n\n# Verify ISO boot configs (all three layers)\nosirrox -indev output.iso -extract /boot/grub2/grub.cfg /tmp/bios-grub.cfg\nosirrox -indev output.iso -extract /EFI/BOOT/grub.cfg /tmp/efi-grub.cfg\nosirrox -indev output.iso -extract /images/efiboot.img /tmp/efiboot.img\nmcopy -n -i /tmp/efiboot.img ::/EFI/BOOT/grub.cfg /tmp/efi-internal-grub.cfg 2>/dev/null \\\n  || mcopy -n -i /tmp/efiboot.img ::/EFI/fedora/grub.cfg /tmp/efi-internal-grub.cfg\ngrep inst.ks= /tmp/bios-grub.cfg /tmp/efi-grub.cfg /tmp/efi-internal-grub.cfg\n```\n\n## Acceptance\n\n- [ ] `losetup --find --show <tempfile>` used as the pre-flight probe (actual attachment test)\n- [ ] Probe cleans up temp file and detaches loop device via trap on all exit paths\n- [ ] Defense-in-depth: mkksiso mkefiboot/losetup failure triggers max-once retry\n- [ ] `mtools` added to `iso/Containerfile`\n- [ ] EFI label patching: grub.cfg discovered via `mcopy` probes, label replaced via `python3 -c` with `re.sub`\n- [ ] Appended EFI partition: xorriso decision table (4 cases) for re-injection\n- [ ] BIOS verification uses `boot/grub2/grub.cfg` (not isolinux/syslinux)\n- [ ] ISO-level `EFI/BOOT/grub.cfg` verified for `inst.ks=` (separate from efiboot.img)\n- [ ] When `--skip-mkefiboot`: efiboot.img patching injects `inst.ks=` and replaces `hd:LABEL=` references\n- [ ] Post-patch verification confirms efiboot.img has correct label AND `inst.ks=`\n- [ ] No duplicate `inst.ks=` in any boot config layer\n- [ ] `implantisomd5` re-run after ISO rewrite; sha256 regenerated\n- [ ] `iso/README.md` updated\n- [ ] `shellcheck iso/build-iso.sh` passes\n\n## References\n\n- PR #4 (commit `2788642`): original losetup skip fix\n- lorax `mkksiso.py` source: `EditGrub2()` handles `EFI/BOOT/grub.cfg`, `boot/grub2/grub.cfg`, `boot/grub/grub.cfg`\n- lorax `EditIsolinux()`: gracefully skips when isolinux.cfg absent\n- lorax `known_configs`: `isolinux/isolinux.cfg`, `boot/grub2/grub.cfg`, `boot/grub/grub.cfg`, `EFI/BOOT/grub.cfg`, `EFI/BOOT/BOOT.conf`\n- Fedora Changes/BIOSBootISOWithGrub2: isolinux removed in Fedora 37\n- `iso/build-iso.sh:1228-1287`: verification function\n- `iso/build-iso.sh:842-1046`: `patch_efiboot_label` function\n- `iso/build-iso.sh:1289-1299`: verify \u2192 patch execution order\n"
  },
  "epic_id": "fn-6-fix-losetup-pre-flight-detection-and",
  "schema_version": 2,
  "tasks": [
    {
      "data": {
        "assignee": null,
        "claim_note": "",
        "claimed_at": null,
        "created_at": "2026-02-17T19:22:35.298700Z",
        "depends_on": [],
        "epic": "fn-6-fix-losetup-pre-flight-detection-and",
        "id": "fn-6-fix-losetup-pre-flight-detection-and.1",
        "priority": null,
        "spec_path": ".flow/tasks/fn-6-fix-losetup-pre-flight-detection-and.1.md",
        "status": "todo",
        "title": "Strengthen losetup probe, add mtools patching, fix duplicate inst.ks",
        "updated_at": "2026-02-17T19:45:27.993809Z"
      },
      "id": "fn-6-fix-losetup-pre-flight-detection-and.1",
      "runtime": {
        "assignee": "erodriguez@greentube.com",
        "claim_note": "",
        "claimed_at": "2026-02-17T19:52:08.213604Z",
        "evidence": {
          "commits": [
            "80e53ab8887baa4faf566f4cbe9e85c10647f7c0"
          ],
          "prs": [],
          "tests": [
            "bash -n iso/build-iso.sh",
            "python3 label extraction/replacement end-to-end tests"
          ]
        },
        "status": "done",
        "updated_at": "2026-02-17T20:38:34.214896Z"
      },
      "spec": "## Description\n\nFix three related issues in `stage_assemble_iso()` that cause ISO builds to fail or produce non-bootable UEFI USB media when loop devices are unavailable.\n\n**Size:** M\n**Files:** `iso/build-iso.sh`, `iso/Containerfile`, `iso/README.md`\n\n## Approach\n\n### 1. Strengthen losetup pre-flight probe (`build-iso.sh:860-868`)\n\nReplace the weak `losetup --find` query with an actual attachment test:\n\n- Create a 1 MiB temp file via `truncate -s 1M`\n- Attempt `losetup --find --show <tempfile>` \u2014 tests the exact operation mkefiboot uses\n- On success: detach with `losetup -d`, remove temp file, proceed without `--skip-mkefiboot`\n- On failure: remove temp file, add `--skip-mkefiboot` + trigger efiboot.img patching\n- Use a trap to ensure cleanup on any exit path (temp file + loop device)\n\n**Defense-in-depth retry:** Even when the probe succeeds, capture mkksiso's stderr to a temp file. If mkksiso exits non-zero, check stderr against a tight set of substrings: `mkefiboot`, `losetup:`, `loop_attach`, `failed to set up loop device`. On match: remove/rename any partially written output ISO, retry at most ONCE with `--skip-mkefiboot` + patching (keep both stderr logs). On retry failure: print BOTH attempts' stderr before exiting non-zero. On non-matching error: fail immediately (don't mask unrelated errors).\n\n### 2. mtools efiboot.img patching (`build-iso.sh`, new helper function)\n\nWhen `--skip-mkefiboot` is active and `-V` changes the volume label, patch EFI boot artifacts in the output ISO. This is a single new function (e.g., `patch_efiboot_label`).\n\n**Step A \u2014 Extract efiboot.img from the output ISO:**\n```\nosirrox -indev <output> -extract /images/efiboot.img /tmp/efiboot.img\n```\n\n**Step B \u2014 Discover grub.cfg inside the FAT image:**\nProbe an ordered list of known candidate paths using direct existence checks (FAT is case-insensitive; mtools handles this):\n1. Try `mcopy -n -i /tmp/efiboot.img ::/EFI/BOOT/grub.cfg /dev/null 2>/dev/null` \u2014 if exit 0, path exists\n2. Try `mcopy -n -i /tmp/efiboot.img ::/EFI/fedora/grub.cfg /dev/null 2>/dev/null`\n\nUse the first path that succeeds. If none found, **hard-fail** the build with a clear error.\n\n**Step C \u2014 Extract, patch, and write back grub.cfg:**\n- Extract: `mcopy -i /tmp/efiboot.img ::<path>/grub.cfg /tmp/efi-grub.cfg`\n- Extract original label(s) from grub.cfg. Support ALL common GRUB search variants:\n  - `search.*--label\\s+'([^']+)'` (single-quoted, long flag)\n  - `search.*--label\\s+\"([^\"]+)\"` (double-quoted, long flag)\n  - `search.*--label\\s+(\\S+)` (unquoted, long flag)\n  - `search.*-l\\s+'([^']+)'` (single-quoted, short flag)\n  - `search.*-l\\s+\"([^\"]+)\"` (double-quoted, short flag)\n  - `search.*-l\\s+(\\S+)` (unquoted, short flag)\n  Hard-fail if no label token found. If multiple DISTINCT labels are found, hard-fail (ambiguous \u2014 can't safely patch).\n- Replace using **targeted** `python3 -c` substitution (python3 is guaranteed present \u2014 lorax dependency). Use `re.sub` with `re.escape()` for the old label, only rewriting the `--label`/`-l` operand. Preserve the original quoting style. Patch ALL occurrences of the discovered label.\n- Write back: `mcopy -o -i /tmp/efiboot.img /tmp/efi-grub.cfg ::<path>/grub.cfg`\n- **Verify:** Re-extract grub.cfg after write-back. Assert: old label count == 0 AND new label count >= 1. Hard-fail on mismatch.\n\n**Step D \u2014 Detect appended EFI partition and re-inject:**\nParse `xorriso -indev <output> -report_system_area plain 2>&1`.\n\nDecision table:\n1. If `xorriso` exits non-zero \u2192 **hard-fail** (print output)\n2. If exit 0 and regex `^Partition\\s+(\\d+).*type\\s+0xEF` finds exactly one indexed match \u2192 use detected index N for `-append_partition N 0xEF`\n3. If exit 0 and regex finds no matches \u2192 treat as El Torito-only; do `-update` only\n4. If exit 0 and regex finds >1 distinct indices \u2192 **hard-fail** (ambiguous)\n\nOnly lines containing BOTH a partition index AND `type 0xEF` are matched. Other EFI hints without an index are informational only (not used for parsing).\n\n**When appended EFI partition exists (case 2):**\n```\nxorriso -indev <output> -outdev <fixed> \\\n    -boot_image any replay \\\n    -update /tmp/efiboot.img /images/efiboot.img \\\n    -append_partition <N> 0xEF /tmp/efiboot.img\n```\n\n**When NO appended EFI partition (case 3):**\n```\nxorriso -indev <output> -outdev <fixed> \\\n    -boot_image any replay \\\n    -update /tmp/efiboot.img /images/efiboot.img\n```\n\n**Step E \u2014 Re-implant media checksum + regenerate sha256:**\n- Run `implantisomd5 <fixed>` to restore media check metadata\n- Ensure the existing sha256 generation at the end of `stage_assemble_iso` runs on the patched ISO\n\n### 3. Add mtools to Containerfile (`Containerfile:12-21`)\n\nAdd `mtools` to the `dnf5 install` line. Required unconditionally since loop device availability is only known at runtime. `python3` is already guaranteed present (lorax dependency) \u2014 no additional install needed for the label replacement.\n\n### 4. Fix duplicate `inst.ks` entries (`build-iso.sh:870-875`)\n\nDrop `-c \"inst.ks=cdrom:/ks.cfg\"` \u2014 let mkksiso's `--ks` flag handle it.\n\n**Verification (mandatory):** After mkksiso produces the output ISO, verify BOTH boot paths:\n\n- **BIOS:** Extract from ISO filesystem \u2014 probe `/isolinux/isolinux.cfg`, `/syslinux/syslinux.cfg`. Assert exactly one `inst.ks=` in the found config.\n- **EFI:** Extract `efiboot.img` from the output ISO, then extract `grub.cfg` from inside it via mtools (same discovery flow as Step 2B). Assert exactly one `inst.ks=` in the found grub.cfg. This verifies the ACTUAL config that UEFI firmware reads at boot.\n\nHard-fail with a clear message if configs can't be located. Log the actual cmdline.\n\n### 5. Update docs (`iso/README.md:210-225`)\n\nThe current README claims `--skip-mkefiboot` is \"safe \u2014 UEFI boot works correctly with the original EFI image.\" Update to reflect:\n- The stronger probe mechanism (actual attachment test + retry fallback)\n- The mtools-based efiboot.img patching that preserves UEFI USB boot with custom labels\n- The `implantisomd5` re-implantation after ISO rewrite\n- When rootful build is still needed (custom EFI partition beyond label patching)\n\n### Commit strategy\n\nTwo commits within a single PR to reduce blast radius:\n1. **Commit 1:** Losetup probe strengthening + duplicate `inst.ks` fix + mtools in Containerfile\n2. **Commit 2:** efiboot.img patching function + implantisomd5 + README update\n\n## Key context\n\n- `--skip-mkefiboot` is a valid mkksiso flag (`lorax/src/bin/mkksiso:L574`). It skips `RebuildEFIBoot()`.\n- mtools `mcopy -i <img>` operates directly on FAT images without loop devices (Arch archiso, linuxkit).\n- FAT is case-insensitive; mtools handles this natively. Use direct `mcopy` existence probes.\n- Use `python3 -c` with `re.sub` + `re.escape()` for label replacement \u2014 python3 is guaranteed present via lorax dependency, avoids the `perl` availability question and `sed` escaping issues.\n- `implantisomd5` (from isomd5sum package, already in Containerfile) must be re-run after any ISO rewrite.\n- The UEFI boot config that firmware reads is INSIDE `efiboot.img`, not the ISO filesystem's `/EFI/BOOT/grub.cfg`.\n- On retry, remove/rename partially written output ISO before rerunning mkksiso.\n\n## Acceptance\n\n- [ ] Pre-flight probe uses `losetup --find --show <tempfile>` (actual attachment test, not bare `--find`)\n- [ ] Probe temp file and loop device cleaned up via trap on all exit paths\n- [ ] Defense-in-depth: mkksiso mkefiboot/losetup failure (tight substring match) triggers max-once retry; partial output ISO removed before retry; both attempts' stderr preserved; non-matching errors fail immediately\n- [ ] `mtools` added to `iso/Containerfile`\n- [ ] grub.cfg location inside efiboot.img discovered by direct `mcopy` existence probes on ordered candidate paths; build hard-fails if not found\n- [ ] Label extracted from grub.cfg via regex supporting `--label`/`-l` with single-quoted/double-quoted/unquoted variants; hard-fails if no label or multiple distinct labels found\n- [ ] Label replacement uses `python3 -c` with `re.sub` + `re.escape()` (python3 guaranteed via lorax); post-replacement re-extraction verifies old label gone (0 hits) and new label present (>= 1 hit)\n- [ ] Appended EFI partition: xorriso non-zero \u2192 hard-fail; exactly one `Partition N ... type 0xEF` \u2192 replace at index N; no match \u2192 `-update` only; >1 distinct indices \u2192 hard-fail\n- [ ] `implantisomd5` re-run after any post-mkksiso ISO rewrite; sha256 regenerated\n- [ ] No duplicate `inst.ks` \u2014 BIOS verified via ISO filesystem config; EFI verified via efiboot.img mtools extraction\n- [ ] `iso/README.md` corrects misleading \"safe\" claim\n- [ ] `shellcheck iso/build-iso.sh` passes; CI unaffected\n\n## Done summary\nStrengthened losetup pre-flight probe to test actual loop device attachment (not just availability), added mtools-based efiboot.img patching to fix UEFI boot label mismatch when --skip-mkefiboot is active, removed duplicate inst.ks= entries, and updated Containerfile and README.\n## Evidence\n- Commits: 80e53ab8887baa4faf566f4cbe9e85c10647f7c0\n- Tests: bash -n iso/build-iso.sh, python3 label extraction/replacement end-to-end tests\n- PRs:"
    },
    {
      "data": {
        "assignee": null,
        "claim_note": "",
        "claimed_at": null,
        "created_at": "2026-02-18T07:52:32.772444Z",
        "depends_on": [
          "fn-6-fix-losetup-pre-flight-detection-and.1"
        ],
        "epic": "fn-6-fix-losetup-pre-flight-detection-and",
        "id": "fn-6-fix-losetup-pre-flight-detection-and.2",
        "priority": null,
        "spec_path": ".flow/tasks/fn-6-fix-losetup-pre-flight-detection-and.2.md",
        "status": "todo",
        "title": "Fix BIOS/EFI boot config verification and efiboot.img inst.ks injection",
        "updated_at": "2026-02-18T07:53:13.663284Z"
      },
      "id": "fn-6-fix-losetup-pre-flight-detection-and.2",
      "runtime": null,
      "spec": "# fn-6-fix-losetup-pre-flight-detection-and.2 Fix BIOS/EFI boot config verification and efiboot.img inst.ks injection\n\n## Description\nFix `_verify_no_duplicate_inst_ks()` (L1228-1287) and expand `patch_efiboot_label()` (L842-1046) to handle Fedora 43 UEFI-only ISOs correctly.\n\n**Three bugs discovered:**\n\n1. **BIOS config lookup uses wrong paths**: Checks `isolinux/isolinux.cfg` and `syslinux/syslinux.cfg`, which don't exist on Fedora 43 (dropped in F37). Must use `boot/grub2/grub.cfg` / `boot/grub/grub.cfg`.\n\n2. **Missing ISO-level EFI check**: The function checks efiboot.img's *internal* grub.cfg but not the ISO filesystem's `EFI/BOOT/grub.cfg` (optical disc UEFI boot path). mkksiso's `EditGrub2()` modifies both.\n\n3. **No `inst.ks=` in efiboot.img when `--skip-mkefiboot`**: mkksiso's `RebuildEFIBoot()` is skipped entirely, leaving efiboot.img untouched \u2014 no `inst.ks=` injected, old `hd:LABEL=` references remain. Current `patch_efiboot_label` only fixes `search --label` lines, not `hd:LABEL=` or `inst.ks=` injection.\n\n**Size:** M\n**Files:** `iso/build-iso.sh` (primary), `iso/README.md` (docs)\n\n## Approach\n\n### A. Fix BIOS config candidates (L1233-1248)\n\nReplace the candidate list following mkksiso's own `known_configs` from `mkksiso.py`:\n- `boot/grub2/grub.cfg` (Fedora 43 standard)\n- `boot/grub/grub.cfg` (fallback for older lorax)\n- Keep `isolinux/isolinux.cfg` and `syslinux/syslinux.cfg` as trailing fallbacks for older ISOs\n\nWhen NO candidate is found: warn (not hard-fail) since Surface Go 3 is UEFI-only and BIOS boot is not required. Require at least one of BIOS or ISO-level EFI.\n\n### B. Add ISO-level EFI config check\n\nAfter the BIOS check, extract `/EFI/BOOT/grub.cfg` from the ISO filesystem using `osirrox`. This is the optical disc UEFI boot path (separate from efiboot.img for USB). Run `_assert_no_dup_inst_ks_in_file` on it.\n\n### C. Restructure verification timing\n\nSplit `_verify_no_duplicate_inst_ks` into two phases:\n- **Pre-patch** (`_verify_inst_ks_iso_configs`): Check ISO-level configs (BIOS GRUB2 + EFI GRUB on ISO filesystem). Always runs at L1289.\n- **Post-patch** (`_verify_inst_ks_efiboot`): Check efiboot.img internal grub.cfg. Runs after `patch_efiboot` when `--skip-mkefiboot`, or at L1289 alongside pre-patch when `--skip-mkefiboot` is NOT active.\n\n### D. Expand `patch_efiboot_label` \u2192 `patch_efiboot`\n\nRename function. In addition to existing label replacement in `search --label`/`-l` lines:\n\n1. **Replace `hd:LABEL=<old>` references**: Use blanket `re.sub(re.escape(old_label), new_label, content)` on the entire grub.cfg (this is what mkksiso's `EditGrub2()` does internally). The existing targeted approach for `search` lines can be replaced by this blanket approach since the old label should be fully replaced everywhere.\n\n2. **Inject `inst.ks=`**: For each `linux`/`linuxefi` line that lacks `inst.ks=`, append `inst.ks=hd:LABEL=<new_label>:/<ks_filename>`. The kickstart filename comes from the mkksiso `--ks` argument basename \u2014 pass it as a parameter to `patch_efiboot`.\n\n3. **Post-patch verification**: After write-back, verify:\n   - Old label count == 0\n   - New label count >= 1\n   - Exactly one `inst.ks=` per `linux`/`linuxefi` line\n   - No `linux`/`linuxefi` line without `inst.ks=`\n\n### E. Update call site (L1289-1299)\n\n```\n# Current flow:\n_verify_no_duplicate_inst_ks \"$output_iso\"          # L1289\nif [[ \"$needs_efi_patch\" == true ]]; then            # L1294\n    patch_efiboot_label \"$output_iso\" \"SurfaceLinux-43\"\nfi\n\n# New flow:\n_verify_inst_ks_iso_configs \"$output_iso\"\nif [[ \"$needs_efi_patch\" == true ]]; then\n    patch_efiboot \"$output_iso\" \"SurfaceLinux-43\" \"kickstart.ks\"\nfi\n_verify_inst_ks_efiboot \"$output_iso\"\n```\n\n### F. Update `iso/README.md`\n\n- Troubleshooting: remove obsolete isolinux reference, add GRUB2 context\n- Stage 11 description: mention three-layer boot config verification\n\n## Key context\n\n- Fedora 37+ removed isolinux/syslinux \u2014 BIOS boot uses GRUB2 via `eltorito.img` + `boot/grub2/grub.cfg`\n- mkksiso `EditGrub2()` modifies: `EFI/BOOT/grub.cfg`, `boot/grub2/grub.cfg`, `boot/grub/grub.cfg`, `EFI/BOOT/BOOT.conf`\n- mkksiso `EditIsolinux()` gracefully skips when `isolinux.cfg` is absent \u2014 our verification should mirror this\n- `--skip-mkefiboot` skips `RebuildEFIBoot()` entirely \u2014 efiboot.img is untouched (no label update, no `inst.ks=` injection)\n- mkksiso injects: `inst.ks=hd:LABEL=<volid>:/<ks_basename>`\n- `osirrox` paths need leading `/` (e.g., `/boot/grub2/grub.cfg`)\n- `EFI/BOOT/BOOT.conf` (Apple EFI) \u2014 likely not present on Fedora 43 x86_64, can ignore\n## Acceptance\n- [ ] BIOS config verification checks `boot/grub2/grub.cfg` and `boot/grub/grub.cfg` (not isolinux/syslinux)\n- [ ] Missing BIOS config is a warning, not a hard-fail (UEFI-only is valid for Surface Go 3)\n- [ ] ISO-level `EFI/BOOT/grub.cfg` extracted and verified for `inst.ks=` (no duplicates, at least one present)\n- [ ] Verification split: ISO-level configs pre-patch, efiboot.img post-patch\n- [ ] `patch_efiboot_label` renamed to `patch_efiboot` \u2014 accepts kickstart filename parameter\n- [ ] `patch_efiboot` replaces ALL old label occurrences (not just `search` lines) \u2014 covers `hd:LABEL=` references\n- [ ] `patch_efiboot` injects `inst.ks=hd:LABEL=<label>:/<ks_file>` into `linux`/`linuxefi` lines lacking it\n- [ ] Post-patch verification: old label gone, new label present, exactly one `inst.ks=` per boot entry\n- [ ] `implantisomd5` + sha256 regenerated after patching (existing behavior preserved)\n- [ ] `iso/README.md` troubleshooting updated for GRUB2 boot configs\n- [ ] `shellcheck iso/build-iso.sh` passes\n- [ ] At least one of BIOS or EFI ISO-level config must exist (hard-fail if neither found)\n## Done summary\nTBD\n\n## Evidence\n- Commits:\n- Tests:\n- PRs:\n"
    }
  ]
}
